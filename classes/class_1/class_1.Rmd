---
title: "Class 1 - basic functionality"
output: 
  learnr::tutorial:
    highlight: tango
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = TRUE,
                      include = TRUE,
                      eval = TRUE)
```

## Introduction to MoBPS

The following tutorial will lead you through the basic functionality of the R package MoBPS (Modular Breeding Program Simulator; <a href="https://www.biorxiv.org/content/10.1101/829333v1">www.biorxiv.org/content/10.1101/829333v1</a>) which can be found at <a href="https://github.com/tpook92/MoBPS">GitHub</a>.

If you do not know much about the intension and the general set up of the Simulation program yet, enjoy the presentation of Torsten in the following video.

![](https://youtu.be/uNeuCkWBNtg)


## Prerequisites

Before you can use MoBPS, you need to install the package on your computer. It is also helpful to install the packages `RandomFieldsUtils` and and `miraculix`, as they can speed up calculations.  
  
Following code installs some packages which are needed packages for the installation from GitHub. If you run this tutorial on your computer, it was automatically performed when starting the tutorial and no further action is required by you.

```{r install_packages, echo=TRUE}
pck <- c('devtools','stringr')
install.packages(pck[!pck %in% rownames(installed.packages())])
invisible(lapply(pck,library,character.only = TRUE, quietly = TRUE))
```

We can now install working `RandomFieldsUtils` and `miraculix` versions. Again - no action is required by you, if you run this tutorial on your computer.

```{r install_dependencies, eval=FALSE, exercise=FALSE, include=TRUE}
pck <- character(2)
temp <- readLines('https://github.com/tpook92/MoBPS')
pck[1] <- str_extract(grep('RandomFieldsUtils_[0-9.]+tar.gz',temp, value = TRUE),
                      'RandomFieldsUtils_[0-9.]+tar.gz')[[1]]
pck[2] <- str_extract(grep('miraculix_[0-9.]+tar.gz', temp, value = TRUE),
                      'miraculix_[0-9.]+tar.gz')[[1]]
pck <- paste0('https://github.com/tpook92/MoBPS/raw/master/', pck)
install.packages(pck, repos = NULL, type = 'source')


```


Finally, we install the newest `MoBPS` version from GitHub.

```{r install_MoBPS, echo=TRUE, exercise=FALSE}
devtools::install_github('tpook92/MoBPS/pkg')
library(MoBPS)
```

## Introduction to the R package

The R package MoBPS is mainly based on two functions: `creating.diploid()` for the creation of random animals and `breeding.diploid()` to mimic breeding actions (e.g. mating and selection of groups). The following video will introduce you to the basic concept, but the content is also captured by this tutorial.  
  
  
![](https://www.youtube.com/watch?v=xAl51woiU5s)  
  

The course will therefore teach you how to simulate following breeding program.  
  

```{r echo=FALSE, out.width = "400px", fig.cap="Figure 1: The scheme behind the breeding program which we will simulate in this course."}
knitr::include_graphics("https://github.com/johannesgeibel/MoBPSteach/raw/master/classes/class_1/breedinProgram.png")
```

## Creation of a base population

### Base population without phenotype

We will start by simulating a population of 50 individuals and 500 SNPs. The basic function to do so is `creating.diploid()`, which creates the initial population list of founder animals. There also exists a tailored `summary()` function, printing the most necessary information. 

```{r show_base_creation, echo=TRUE}
popList <- creating.diploid(nindi = 50, # number of individuals
                            nsnp = 500) # number of SNP
summary(popList)
```

As you noticed, MoBPS automatically divided the population into 50% male and 50% female individuals and assigned them to seperate cohorts (a group of individuals  which share properties at a special timepoint). So the population consists of two cohorts.  
  
If you want to change this (e.g. only males or more females than males), add the parameter `sex.quota` which specifies the share of female individuals. So following code creates the same population as before, just all individuals being male. You can additionally name your cohort by the parameter `name.cohort`.

```{r show_base_creation_2, echo=TRUE}
popList <- MoBPS::creating.diploid(nindi =  50,
                                   sex.quota = 0, # share of females
                                   name.cohort = 'founder_male', # name of the cohort
                                   nsnp = 500)
summary(popList)

```

If you want to add additional founder cohorts, use `creating.diploid()` on the existing population (specified via `population`). It is necessary to also specify the genome info again.

```{r}
popList <- MoBPS::creating.diploid(population = popList, # existing population to which the new individuals will be added
                                   nindi =  50,
                                   sex.quota = 1,
                                   name.cohort = 'founder_female',
                                   nsnp = 500)
summary(popList)
```


If you want to extract the names of all cohorts in the population, use `get.cohorts()`. If you set `extended = TRUE`, you will get a matrix with more information instead of a simple vector.

```{r}
get.cohorts(popList)
get.cohorts(popList, extended = TRUE)
```


By now, all markers are located on one single chromosome with a default length of 5 Morgan (M) and a physical size of 5 kilo bases (kb). The number of chromosomes can be eighter changed by the parameter `chr.nr` which leads to the according number of 5M chromosomes, or by directly supplying an vector with the intended legthes in M via `chromosome.length`.

```{r}
temp <- creating.diploid(nindi =  50,
                         sex.quota = 0,
                         nsnp = 500,
                         chr.nr = 2) # number of 5M chromosomes 
summary(temp)

temp <- creating.diploid(nindi =  50,
                         sex.quota = 0, 
                         nsnp = 500,
                         chromosome.length = c(2,1,0.5)) # chromosome length [M]
summary(temp)

```




### exercise 1
Now it's your turn. Create a population `ownPop` of 60 males (cohort "founder_male"), 60 females (cohort "founder_female") and 500 SNPs on two chromosomes.

```{r creation, exercise=TRUE, exercise.lines = 12}



```


```{r creation-solution}
ownPop <- creating.diploid(nindi = 60,
                            sex.quota = 0,
                            nsnp = 500,
                            chr.nr = 2)
ownPop <- creating.diploid(population = ownPop,
                           nindi = 60,
                           sex.quota = 1,
                           nsnp = 500,
                           chr.nr = 2)
summary(ownPop)

```


It is also possible to create a base population from real data by supplying e.g. a VCF file.

```{r eval=FALSE, include=TRUE}
creating.diploid(vcf = "/path/to/file.vcf")
```

## Traits
### Adding traits to the base population

By now, our base population consists only of individuals with genomes. To simulate breeding programs, we need to additionally simulate phenotypic traits and the according genetic basis. We will start doing so by randomly drawing additive effects from a normal distribution with additive variance of $\sigma_{A;MKG}^2=25^2kg^2$ for 100 SNP which contribute to the trait milk yield [kg] (MKG) via the function `creating.trait()`. Note that it is also possible to directly simulate the trait in `creating.diploid()`.

```{r}
popList <- creating.trait(population = popList,
                          # name of trait
                          trait.name = 'MKG',
                          # number of additive effects
                          n.additive = 100,
                          # additive target variance
                          var.additive.l = 25^2)
summary(popList)
get.cohorts(popList)
```



```{r echo=FALSE, include=FALSE, eval=FALSE}
hist(popList$info$real.bv.add[[1]][,5],
     freq = FALSE, main = '', xlab = 'additive effect')
lines(density(popList$info$real.bv.add[[1]][,5]))
lines(seq(-3,3,0.01), dnorm(seq(-3,3,0.01)), col = 'red')
legend('topright',
       legend = c('simulated', 'standard normal'),
       col = c('black', 'red'),
       lty = 1)
```


Adding a second trait can be performed in the same way, but it is necessary to specify residual and genetic correlation. Note that the residual correlation is named phenotype correlation by now. We specify a second trait fat percentage (FP) with additive variance ($r_{A;FP}$) is $4\%^2$. Our additive genetic correlation ($r_{A;MKG;FP}$) to be 0.5 and the environments are assumed to be uncorrelated for now ($r_E=0$).

```{r}
popList <- creating.trait(population = popList,
                       trait.name = c('FP'), 
                       n.additive = 200,
                       var.additive.l = 2^2,
                       # indices of correlated traits
                       shuffle.traits = c(1,2),
                       # genetic correlation (0.5) matrix
                       shuffle.cor = matrix(c(1,.5,
                                              .5,1),2,2),
                       # residual correlation (0) matrix
                       new.phenotype.correlation = matrix(c(1,0,
                                                            0,1),2,2)
                       )
summary(popList)

```

Be aware that using a genetic and residual correlation matrix which results in not defined phenotypic correlations, will throw an error message. Note that such a correlation cannot occur in practice even though pair-wise correlation estimations might lead to such estimates:

```{r error=TRUE}
temp <- creating.trait(population = popList,
                       shuffle.traits = c(1,2),
                       shuffle.cor = matrix(c(1,.5,
                                              .5,1),2,2),
                       new.phenotype.correlation = matrix(c(1,-1,
                                                            -1,1),2,2))
```

### Exercise

```{r traits, exercise=TRUE, exercise.lines = 5}



```

```{r traits-solution}
# solution 1 --> create traits after population
#popList <- MoBPS::creating.diploid(nindi =  100,
#                                   nsnp = 1000)
#popList <- MoBPS::creating.trait(population = popList,
#                                 trait.name = c('traitA','traitB'),
#                                 n.additive = c(150,20),
#                                 var.additive.l = list(traitA = 1,traitB = 2),
#                                 new.phenotype.correlation = matrix(c(1,0.5,0.5,1),2,2),
#                                 shuffle.traits = 1:2,
#                                 shuffle.cor = matrix(c(1,0.2,0.2,1),2,2))
#summary(popList)
# solution 2 --> create traits directly
#popList <- MoBPS::creating.diploid(nindi =  100,
#                                   nsnp = 1000,
#                                   trait.name = c('traitA','traitB'),
 #                                  n.additive = c(150,20),
 ##                                  var.additive.l = list(traitA = 1,traitB = 2),
#                                   new.phenotype.correlation = matrix(c(1,0.5,0.5,1),2,2),
#                                   shuffle.traits = 1:2,
#                                   shuffle.cor = matrix(c(1,0.2,0.2,1),2,2))
#summary(popList)

```



## Breeding Actions


### Generation of a population structure (random mating)

The individuals in the founder population are unrelated.This is normally not the case in practice. Simulations therefore start with a number of burn in generations which simply apply random mating. The function for all breeding actions is `breeding.diploid()`. It generates new individuals by mating old ones and thereby simulating recombination and mutation events. If not specified differently, the last available males and females are chosen for random mating.

```{r}
temp <- breeding.diploid(population = popList,
                         # number of newly created individuals
                         breeding.size = 100,
                         verbose = FALSE) # suppress progress report
summary(temp)

```

When applying the function `get.cohorts()` on the updated population, we see that a male and a female cohort, each of size 50, were created in generation 2.

```{r}
get.cohorts(temp, extended = TRUE)

```

As we do not only want to run it for one burn in generation, but for five, we use a loop to save code lines and additionally use a more usefull cohort name.

```{r}
n_burnin <- 5
for(i_burnin in 1:n_burnin){
  popList <- breeding.diploid(popList,
                           breeding.size = 100,
                           name.cohort = paste0('burnin_',i_burnin),
                           verbose = FALSE)
}

summary(popList)
```

The population now exists of 600 individuals in 6 generations (1 founder and 5 burnin) and 12 cohorts. MoBPS automatically added "_M" and "_F" to the cohort names.

```{r}
tail(get.cohorts(popList, extended = TRUE))
```



```{r burnin, exercise=TRUE, exercise.lines = 12}



```


```{r burnin-solution}
ownPop <- creating.diploid(nindi = 60,
                            sex.quota = 0,
                            nsnp = 500,
                            chr.nr = 2)
ownPop <- creating.diploid(population = ownPop,
                           nindi = 60,
                           sex.quota = 1,
                           nsnp = 500,
                           chr.nr = 2)
summary(ownPop)

```

### Selection

The basic principle of breeding is that we do not use all individuals, but only a selected subset for matings. Let's start with random selecting 5 males from the last generation and assining an own cohort name to them.  

```{r eval=FALSE}
temp <- breeding.diploid(popList,
                         selection.size = 5, # selected number
                         selection.criteria = 'random', # criterium
                         selection.m.cohorts = 'new_5_M', # from cohort
                         
                         name.cohort = 'selected_male',
                         # generation number has still to be 6
                         add.gen = n_burnin + 1,
                         # copying individuals instead of creating new ones
                         copy.individual.m = TRUE)
summary(temp)
tail(get.cohorts(temp,extended = TRUE))

```


If we do not only want to apply random selection, but selecting the best males based on estimated breeding values (EBV), we need to additionally simulate phenotypes for our individuals. This needs the additional specification of the environemental variances ($\sigma^2_E$) of the traits. Remember Following connenction between heritability ($h^2$), $\sigma^2_A$ and $\sigma^2_E$:
 
$$h^2=\frac{\sigma^2_A}{\sigma^2_A + \sigma^2_E}$$

$$\sigma^2_E=\frac{\sigma^2_A}{h^2} - \sigma^2_A = \frac{\sigma^2_A (1-h^2)}{h^2}$$

If we assume heritabilities of 0.8 respectively 0.3 for both of our traits, $\sigma^2_{E;MKG}=156.25$ and $\sigma^2_{E;FP}=9.33$. As only female cows can give milk, we simulate the phenotypes for all not yet phenotyped females by the following code. Note that you have to set `sigma.e` only once, if you do not assume changes over the generations!

```{r eval=FALSE, include=FALSE}
(25^2*(1-0.8))/0.8
(2^2*(1-0.3))/0.3

```


```{r phenotyping}
popList <- breeding.diploid(popList,
                            new.bv.observation = "non_obs_f",
                            sigma.e = c(156.25, 9.33)) # heritability = c(0.8,0.3) 
```


We do now select 10 out of 50 males from the last cohort. Breeding values for the males are estimated from female phenotypes via genomic breeding value estimation (default).

```{r eval=FALSE}
temp <- breeding.diploid(popList,
                         selection.size = 10,
                         # selection based on EBVs
                         selection.criteria = 'bve',
                         selection.m.cohorts = 'new_5_M',
                         selection.m.gen = n_burnin + 1,
                         # estimate BV
                         bve = TRUE,
                         # use all by now available generations
                         bve.gen = c(1:(1+n_burnin)),
                         
                         name.cohort = 'selected_male',
                         add.gen = n_burnin + 1,
                         copy.individual.m = TRUE)
summary(temp)

```


### mating and selection

Of course, we want to use these selected males as sires for a new generation. To do so, we can perform selection and mating at once and again use a loop to repeat this process for a number of generations:

```{r eval=TRUE}
n_selection <- 5 # number of selecting generations
for(i_selection in 1:n_selection){
  popList <- breeding.diploid(popList,
                              # create 100 calfes each year
                              breeding.size = 100,
                              # select 5 bulls (10%) and all cows
                              selection.size = c(5,50),
                              # select based on EBVs
                              selection.criteria = 'bve',
                              # estimate breeding values
                              bve = TRUE,
                              # use all previous generations 
                              bve.gen = c(1:(n_burnin + i_selection)),
                              # add phenotypes for new females, if not yet present
                              new.bv.observation = "non_obs_f",
                         
                              name.cohort = paste0('offspring_',i_selection),
                              verbose = FALSE)
}
summary(popList)
```


> Note depending on the size of your population, the number of SNPs and the chosen method, the time needed for breeding value estimation is the big problem of most simulations!


```{r breeding, exercise=TRUE, exercise.lines = 12}



```


```{r breeding-solution}
ownPop <- creating.diploid(nindi = 60,
                            sex.quota = 0,
                            nsnp = 500,
                            chr.nr = 2)
ownPop <- creating.diploid(population = ownPop,
                           nindi = 60,
                           sex.quota = 1,
                           nsnp = 500,
                           chr.nr = 2)
summary(ownPop)

```


## Evaluating results


```{r eval=TRUE}
bv.development(population = popList,
               gen = 1:11,
               development = 1,
               display.cohort.name = TRUE)
```



```{r eval=TRUE}
summary(popList)

#get.geno(popList,cohorts = 'founder_male')

#MoBPS::bv.development(popList,
#                      gen=1:26,
#                      cohorts = c('offspring_M'))
invisible(MoBPS::bv.development.box(popList,
                      gen = 1:11))
invisible(MoBPS::bv.development.box(popList,
                      cohorts = get.cohorts(popList)))

MoBPS::analyze.bv(popList,
                  cohorts = 'burnin_5_M')
MoBPS::analyze.bv(popList,
                  cohorts = 'offspring_4_M')

kinship.development(popList,
                    gen=1:11,
                    display.cohort.name = TRUE )
```


```{r res, exercise=TRUE, exercise.lines = 12}



```


```{r res-solution}




```
